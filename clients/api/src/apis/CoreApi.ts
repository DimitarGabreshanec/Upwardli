/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Address,
    AddressFromJSON,
    AddressToJSON,
    AppleLogin,
    AppleLoginFromJSON,
    AppleLoginToJSON,
    CustomUserDetails,
    CustomUserDetailsFromJSON,
    CustomUserDetailsToJSON,
    FaceBookLogin,
    FaceBookLoginFromJSON,
    FaceBookLoginToJSON,
    FinancialProfile,
    FinancialProfileFromJSON,
    FinancialProfileToJSON,
    GoogleLogin,
    GoogleLoginFromJSON,
    GoogleLoginToJSON,
    Guide,
    GuideFromJSON,
    GuideToJSON,
    GuideGuideModuleRead,
    GuideGuideModuleReadFromJSON,
    GuideGuideModuleReadToJSON,
    GuideModule,
    GuideModuleFromJSON,
    GuideModuleToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    JWT,
    JWTFromJSON,
    JWTToJSON,
    Login,
    LoginFromJSON,
    LoginToJSON,
    Logout,
    LogoutFromJSON,
    LogoutToJSON,
    Offer,
    OfferFromJSON,
    OfferToJSON,
    PasswordChange,
    PasswordChangeFromJSON,
    PasswordChangeToJSON,
    PasswordReset,
    PasswordResetFromJSON,
    PasswordResetToJSON,
    PasswordResetConfirm,
    PasswordResetConfirmFromJSON,
    PasswordResetConfirmToJSON,
    Phone,
    PhoneFromJSON,
    PhoneToJSON,
    Register,
    RegisterFromJSON,
    RegisterToJSON,
    TokenObtainPair,
    TokenObtainPairFromJSON,
    TokenObtainPairToJSON,
    TokenRefresh,
    TokenRefreshFromJSON,
    TokenRefreshToJSON,
    TokenVerify,
    TokenVerifyFromJSON,
    TokenVerifyToJSON,
    UserGuideMultiChoiceFormItems,
    UserGuideMultiChoiceFormItemsFromJSON,
    UserGuideMultiChoiceFormItemsToJSON,
    UserGuideSimpleFormChoice,
    UserGuideSimpleFormChoiceFromJSON,
    UserGuideSimpleFormChoiceToJSON,
    VerifyEmail,
    VerifyEmailFromJSON,
    VerifyEmailToJSON,
} from '../models';

export interface CreateAddressRequest {
    address?: Address;
}

export interface CreateAppleLoginRequest {
    appleLogin?: AppleLogin;
}

export interface CreateFaceBookLoginRequest {
    faceBookLogin?: FaceBookLogin;
}

export interface CreateFinancialProfileRequest {
    financialProfile?: FinancialProfile;
}

export interface CreateGoogleLoginRequest {
    googleLogin?: GoogleLogin;
}

export interface CreateLoginRequest {
    login?: Login;
}

export interface CreateLogoutRequest {
    logout?: Logout;
}

export interface CreatePasswordChangeRequest {
    passwordChange?: PasswordChange;
}

export interface CreatePasswordResetRequest {
    passwordReset?: PasswordReset;
}

export interface CreatePasswordResetConfirmRequest {
    passwordResetConfirm?: PasswordResetConfirm;
}

export interface CreatePhoneRequest {
    phone?: Phone;
}

export interface CreateRegisterRequest {
    register?: Register;
}

export interface CreateTokenObtainPairRequest {
    tokenObtainPair?: TokenObtainPair;
}

export interface CreateTokenRefreshRequest {
    tokenRefresh?: TokenRefresh;
}

export interface CreateTokenVerifyRequest {
    tokenVerify?: TokenVerify;
}

export interface CreateVerifyEmailRequest {
    verifyEmail?: VerifyEmail;
}

export interface DestroyAddressRequest {
    id: string;
    search?: string;
}

export interface DestroyPhoneRequest {
    id: string;
    search?: string;
}

export interface ListAddressRequest {
    search?: string;
}

export interface ListFinancialProfilesRequest {
    limit?: number;
    offset?: number;
    search?: string;
}

export interface ListGuideModulesRequest {
    guide?: string;
}

export interface ListGuidesRequest {
    guideType?: ListGuidesGuideTypeEnum;
}

export interface ListLogoutsRequest {
    limit?: number;
    offset?: number;
    search?: string;
}

export interface ListOffersRequest {
    limit?: number;
    offset?: number;
    category?: ListOffersCategoryEnum;
}

export interface ListPhonesRequest {
    limit?: number;
    offset?: number;
    search?: string;
}

export interface MarkGuideAsReadGuideModuleRequest {
    guideGuideModuleRead?: GuideGuideModuleRead;
}

export interface PartialUpdateAddressRequest {
    id: string;
    search?: string;
    address?: Address;
}

export interface PartialUpdateCustomUserDetailsRequest {
    search?: string;
    customUserDetails?: CustomUserDetails;
}

export interface PartialUpdatePhoneRequest {
    id: string;
    search?: string;
    phone?: Phone;
}

export interface RetrieveAddressRequest {
    id: string;
    search?: string;
}

export interface RetrieveCustomUserDetailsRequest {
    search?: string;
}

export interface RetrieveGuideRequest {
    slug: string;
    guideType?: RetrieveGuideGuideTypeEnum;
}

export interface RetrieveGuideModuleRequest {
    slug: string;
    guide?: string;
}

export interface RetrieveOfferRequest {
    id: string;
    category?: RetrieveOfferCategoryEnum;
}

export interface RetrievePhoneRequest {
    id: string;
    search?: string;
}

export interface RetrievepartnerRequest {
    partnerName: string;
}

export interface RetrieveuserPhonesNumbersRequest {
    opk: string;
}

export interface SaveMultiChoiceFormResultsGuideModuleRequest {
    userGuideMultiChoiceFormItems?: UserGuideMultiChoiceFormItems;
}

export interface SaveSimpleFormResultsGuideModuleRequest {
    userGuideSimpleFormChoice?: UserGuideSimpleFormChoice;
}

export interface UpdateAddressRequest {
    id: string;
    search?: string;
    address?: Address;
}

export interface UpdateCustomUserDetailsRequest {
    search?: string;
    customUserDetails?: CustomUserDetails;
}

export interface UpdatePhoneRequest {
    id: string;
    search?: string;
    phone?: Phone;
}

/**
 * 
 */
export class CoreApi extends runtime.BaseAPI {

    /**
     */
    async createAddressRaw(requestParameters: CreateAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Address>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/addresses/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddressToJSON(requestParameters.address),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressFromJSON(jsonValue));
    }

    /**
     */
    async createAddress(requestParameters: CreateAddressRequest, initOverrides?: RequestInit): Promise<Address> {
        const response = await this.createAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createAppleLoginRaw(requestParameters: CreateAppleLoginRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<JWT>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/social-login-apple/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AppleLoginToJSON(requestParameters.appleLogin),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue));
    }

    /**
     */
    async createAppleLogin(requestParameters: CreateAppleLoginRequest, initOverrides?: RequestInit): Promise<JWT> {
        const response = await this.createAppleLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createFaceBookLoginRaw(requestParameters: CreateFaceBookLoginRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<JWT>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/social-login-facebook/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FaceBookLoginToJSON(requestParameters.faceBookLogin),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue));
    }

    /**
     */
    async createFaceBookLogin(requestParameters: CreateFaceBookLoginRequest, initOverrides?: RequestInit): Promise<JWT> {
        const response = await this.createFaceBookLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Post request will create a profile if it is missing and update it if the profile already exists. Then the response code will be 200.
     */
    async createFinancialProfileRaw(requestParameters: CreateFinancialProfileRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FinancialProfile>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/financial-profile/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FinancialProfileToJSON(requestParameters.financialProfile),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FinancialProfileFromJSON(jsonValue));
    }

    /**
     * Post request will create a profile if it is missing and update it if the profile already exists. Then the response code will be 200.
     */
    async createFinancialProfile(requestParameters: CreateFinancialProfileRequest, initOverrides?: RequestInit): Promise<FinancialProfile> {
        const response = await this.createFinancialProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createGoogleLoginRaw(requestParameters: CreateGoogleLoginRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<JWT>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/social-login-google/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GoogleLoginToJSON(requestParameters.googleLogin),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue));
    }

    /**
     */
    async createGoogleLogin(requestParameters: CreateGoogleLoginRequest, initOverrides?: RequestInit): Promise<JWT> {
        const response = await this.createGoogleLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
     */
    async createLoginRaw(requestParameters: CreateLoginRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<JWT>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/login/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginToJSON(requestParameters.login),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue));
    }

    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
     */
    async createLogin(requestParameters: CreateLoginRequest, initOverrides?: RequestInit): Promise<JWT> {
        const response = await this.createLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createLogoutRaw(requestParameters: CreateLogoutRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Logout>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/logout/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LogoutToJSON(requestParameters.logout),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LogoutFromJSON(jsonValue));
    }

    /**
     */
    async createLogout(requestParameters: CreateLogoutRequest, initOverrides?: RequestInit): Promise<Logout> {
        const response = await this.createLogoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     */
    async createPasswordChangeRaw(requestParameters: CreatePasswordChangeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PasswordChange>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/password/change/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordChangeToJSON(requestParameters.passwordChange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PasswordChangeFromJSON(jsonValue));
    }

    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     */
    async createPasswordChange(requestParameters: CreatePasswordChangeRequest, initOverrides?: RequestInit): Promise<PasswordChange> {
        const response = await this.createPasswordChangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     */
    async createPasswordResetRaw(requestParameters: CreatePasswordResetRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PasswordReset>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/password/reset/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordResetToJSON(requestParameters.passwordReset),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PasswordResetFromJSON(jsonValue));
    }

    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     */
    async createPasswordReset(requestParameters: CreatePasswordResetRequest, initOverrides?: RequestInit): Promise<PasswordReset> {
        const response = await this.createPasswordResetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     */
    async createPasswordResetConfirmRaw(requestParameters: CreatePasswordResetConfirmRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PasswordResetConfirm>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/password/reset/confirm/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PasswordResetConfirmToJSON(requestParameters.passwordResetConfirm),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PasswordResetConfirmFromJSON(jsonValue));
    }

    /**
     * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     */
    async createPasswordResetConfirm(requestParameters: CreatePasswordResetConfirmRequest, initOverrides?: RequestInit): Promise<PasswordResetConfirm> {
        const response = await this.createPasswordResetConfirmRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createPhoneRaw(requestParameters: CreatePhoneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Phone>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PhoneToJSON(requestParameters.phone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PhoneFromJSON(jsonValue));
    }

    /**
     */
    async createPhone(requestParameters: CreatePhoneRequest, initOverrides?: RequestInit): Promise<Phone> {
        const response = await this.createPhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createRegisterRaw(requestParameters: CreateRegisterRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<JWT>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/registration/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterToJSON(requestParameters.register),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue));
    }

    /**
     */
    async createRegister(requestParameters: CreateRegisterRequest, initOverrides?: RequestInit): Promise<JWT> {
        const response = await this.createRegisterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     */
    async createTokenObtainPairRaw(requestParameters: CreateTokenObtainPairRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TokenObtainPair>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/token/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenObtainPairToJSON(requestParameters.tokenObtainPair),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenObtainPairFromJSON(jsonValue));
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     */
    async createTokenObtainPair(requestParameters: CreateTokenObtainPairRequest, initOverrides?: RequestInit): Promise<TokenObtainPair> {
        const response = await this.createTokenObtainPairRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     */
    async createTokenRefreshRaw(requestParameters: CreateTokenRefreshRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TokenRefresh>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/token/refresh/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenRefreshToJSON(requestParameters.tokenRefresh),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenRefreshFromJSON(jsonValue));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     */
    async createTokenRefresh(requestParameters: CreateTokenRefreshRequest, initOverrides?: RequestInit): Promise<TokenRefresh> {
        const response = await this.createTokenRefreshRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     */
    async createTokenVerifyRaw(requestParameters: CreateTokenVerifyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TokenVerify>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/token/verify/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenVerifyToJSON(requestParameters.tokenVerify),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenVerifyFromJSON(jsonValue));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     */
    async createTokenVerify(requestParameters: CreateTokenVerifyRequest, initOverrides?: RequestInit): Promise<TokenVerify> {
        const response = await this.createTokenVerifyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async createVerifyEmailRaw(requestParameters: CreateVerifyEmailRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<VerifyEmail>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/registration/verify-email/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VerifyEmailToJSON(requestParameters.verifyEmail),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifyEmailFromJSON(jsonValue));
    }

    /**
     */
    async createVerifyEmail(requestParameters: CreateVerifyEmailRequest, initOverrides?: RequestInit): Promise<VerifyEmail> {
        const response = await this.createVerifyEmailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async destroyAddressRaw(requestParameters: DestroyAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyAddress.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/addresses/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyAddress(requestParameters: DestroyAddressRequest, initOverrides?: RequestInit): Promise<void> {
        await this.destroyAddressRaw(requestParameters, initOverrides);
    }

    /**
     */
    async destroyPhoneRaw(requestParameters: DestroyPhoneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyPhone.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyPhone(requestParameters: DestroyPhoneRequest, initOverrides?: RequestInit): Promise<void> {
        await this.destroyPhoneRaw(requestParameters, initOverrides);
    }

    /**
     */
    async listAddressRaw(requestParameters: ListAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Address>>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/addresses/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AddressFromJSON));
    }

    /**
     */
    async listAddress(requestParameters: ListAddressRequest, initOverrides?: RequestInit): Promise<Array<Address>> {
        const response = await this.listAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Post request will create a profile if it is missing and update it if the profile already exists. Then the response code will be 200.
     */
    async listFinancialProfilesRaw(requestParameters: ListFinancialProfilesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2001>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/financial-profile/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * Post request will create a profile if it is missing and update it if the profile already exists. Then the response code will be 200.
     */
    async listFinancialProfiles(requestParameters: ListFinancialProfilesRequest, initOverrides?: RequestInit): Promise<InlineResponse2001> {
        const response = await this.listFinancialProfilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async listGuideModulesRaw(requestParameters: ListGuideModulesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<GuideModule>>> {
        const queryParameters: any = {};

        if (requestParameters.guide !== undefined) {
            queryParameters['guide'] = requestParameters.guide;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides-modules/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GuideModuleFromJSON));
    }

    /**
     */
    async listGuideModules(requestParameters: ListGuideModulesRequest, initOverrides?: RequestInit): Promise<Array<GuideModule>> {
        const response = await this.listGuideModulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async listGuidesRaw(requestParameters: ListGuidesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Guide>>> {
        const queryParameters: any = {};

        if (requestParameters.guideType !== undefined) {
            queryParameters['guide_type'] = requestParameters.guideType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GuideFromJSON));
    }

    /**
     */
    async listGuides(requestParameters: ListGuidesRequest, initOverrides?: RequestInit): Promise<Array<Guide>> {
        const response = await this.listGuidesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Redirect with jwt_token in get params
     */
    async listJwtAuthsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<any>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/jwt-auth/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Redirect with jwt_token in get params
     */
    async listJwtAuths(initOverrides?: RequestInit): Promise<Array<any>> {
        const response = await this.listJwtAuthsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async listLogoutsRaw(requestParameters: ListLogoutsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2002>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/logout/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     */
    async listLogouts(requestParameters: ListLogoutsRequest, initOverrides?: RequestInit): Promise<InlineResponse2002> {
        const response = await this.listLogoutsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async listOffersRaw(requestParameters: ListOffersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/offers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     */
    async listOffers(requestParameters: ListOffersRequest, initOverrides?: RequestInit): Promise<InlineResponse200> {
        const response = await this.listOffersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async listPhonesRaw(requestParameters: ListPhonesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<InlineResponse2003>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     */
    async listPhones(requestParameters: ListPhonesRequest, initOverrides?: RequestInit): Promise<InlineResponse2003> {
        const response = await this.listPhonesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark guide as read.
     */
    async markGuideAsReadGuideModuleRaw(requestParameters: MarkGuideAsReadGuideModuleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<GuideGuideModuleRead>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides-modules/mark-guide-as-read/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GuideGuideModuleReadToJSON(requestParameters.guideGuideModuleRead),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GuideGuideModuleReadFromJSON(jsonValue));
    }

    /**
     * Mark guide as read.
     */
    async markGuideAsReadGuideModule(requestParameters: MarkGuideAsReadGuideModuleRequest, initOverrides?: RequestInit): Promise<GuideGuideModuleRead> {
        const response = await this.markGuideAsReadGuideModuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async partialUpdateAddressRaw(requestParameters: PartialUpdateAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Address>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling partialUpdateAddress.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/addresses/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AddressToJSON(requestParameters.address),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdateAddress(requestParameters: PartialUpdateAddressRequest, initOverrides?: RequestInit): Promise<Address> {
        const response = await this.partialUpdateAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     */
    async partialUpdateCustomUserDetailsRaw(requestParameters: PartialUpdateCustomUserDetailsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomUserDetails>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/user/`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: CustomUserDetailsToJSON(requestParameters.customUserDetails),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomUserDetailsFromJSON(jsonValue));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     */
    async partialUpdateCustomUserDetails(requestParameters: PartialUpdateCustomUserDetailsRequest, initOverrides?: RequestInit): Promise<CustomUserDetails> {
        const response = await this.partialUpdateCustomUserDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async partialUpdatePhoneRaw(requestParameters: PartialUpdatePhoneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Phone>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling partialUpdatePhone.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PhoneToJSON(requestParameters.phone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PhoneFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdatePhone(requestParameters: PartialUpdatePhoneRequest, initOverrides?: RequestInit): Promise<Phone> {
        const response = await this.partialUpdatePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async retrieveAddressRaw(requestParameters: RetrieveAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Address>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling retrieveAddress.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/addresses/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressFromJSON(jsonValue));
    }

    /**
     */
    async retrieveAddress(requestParameters: RetrieveAddressRequest, initOverrides?: RequestInit): Promise<Address> {
        const response = await this.retrieveAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     */
    async retrieveCustomUserDetailsRaw(requestParameters: RetrieveCustomUserDetailsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomUserDetails>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/user/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomUserDetailsFromJSON(jsonValue));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     */
    async retrieveCustomUserDetails(requestParameters: RetrieveCustomUserDetailsRequest, initOverrides?: RequestInit): Promise<CustomUserDetails> {
        const response = await this.retrieveCustomUserDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async retrieveGuideRaw(requestParameters: RetrieveGuideRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Guide>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling retrieveGuide.');
        }

        const queryParameters: any = {};

        if (requestParameters.guideType !== undefined) {
            queryParameters['guide_type'] = requestParameters.guideType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GuideFromJSON(jsonValue));
    }

    /**
     */
    async retrieveGuide(requestParameters: RetrieveGuideRequest, initOverrides?: RequestInit): Promise<Guide> {
        const response = await this.retrieveGuideRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async retrieveGuideModuleRaw(requestParameters: RetrieveGuideModuleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<GuideModule>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling retrieveGuideModule.');
        }

        const queryParameters: any = {};

        if (requestParameters.guide !== undefined) {
            queryParameters['guide'] = requestParameters.guide;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides-modules/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GuideModuleFromJSON(jsonValue));
    }

    /**
     */
    async retrieveGuideModule(requestParameters: RetrieveGuideModuleRequest, initOverrides?: RequestInit): Promise<GuideModule> {
        const response = await this.retrieveGuideModuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async retrieveOfferRaw(requestParameters: RetrieveOfferRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Offer>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling retrieveOffer.');
        }

        const queryParameters: any = {};

        if (requestParameters.category !== undefined) {
            queryParameters['category'] = requestParameters.category;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/offers/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OfferFromJSON(jsonValue));
    }

    /**
     */
    async retrieveOffer(requestParameters: RetrieveOfferRequest, initOverrides?: RequestInit): Promise<Offer> {
        const response = await this.retrieveOfferRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async retrievePhoneRaw(requestParameters: RetrievePhoneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Phone>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling retrievePhone.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PhoneFromJSON(jsonValue));
    }

    /**
     */
    async retrievePhone(requestParameters: RetrievePhoneRequest, initOverrides?: RequestInit): Promise<Phone> {
        const response = await this.retrievePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Redirecting to the partner URL
     */
    async retrievepartnerRaw(requestParameters: RetrievepartnerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.partnerName === null || requestParameters.partnerName === undefined) {
            throw new runtime.RequiredError('partnerName','Required parameter requestParameters.partnerName was null or undefined when calling retrievepartner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/partners/{partner_name}/`.replace(`{${"partner_name"}}`, encodeURIComponent(String(requestParameters.partnerName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Redirecting to the partner URL
     */
    async retrievepartner(requestParameters: RetrievepartnerRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.retrievepartnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User\'s phone numbers.
     */
    async retrieveuserPhonesNumbersRaw(requestParameters: RetrieveuserPhonesNumbersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.opk === null || requestParameters.opk === undefined) {
            throw new runtime.RequiredError('opk','Required parameter requestParameters.opk was null or undefined when calling retrieveuserPhonesNumbers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/{opk}/`.replace(`{${"opk"}}`, encodeURIComponent(String(requestParameters.opk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * User\'s phone numbers.
     */
    async retrieveuserPhonesNumbers(requestParameters: RetrieveuserPhonesNumbersRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.retrieveuserPhonesNumbersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Save the results of a multi selection form.
     */
    async saveMultiChoiceFormResultsGuideModuleRaw(requestParameters: SaveMultiChoiceFormResultsGuideModuleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<UserGuideMultiChoiceFormItems>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides-modules/save-multi-choice-form-results/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserGuideMultiChoiceFormItemsToJSON(requestParameters.userGuideMultiChoiceFormItems),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserGuideMultiChoiceFormItemsFromJSON(jsonValue));
    }

    /**
     * Save the results of a multi selection form.
     */
    async saveMultiChoiceFormResultsGuideModule(requestParameters: SaveMultiChoiceFormResultsGuideModuleRequest, initOverrides?: RequestInit): Promise<UserGuideMultiChoiceFormItems> {
        const response = await this.saveMultiChoiceFormResultsGuideModuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Save the results of a simple selection form.
     */
    async saveSimpleFormResultsGuideModuleRaw(requestParameters: SaveSimpleFormResultsGuideModuleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<UserGuideSimpleFormChoice>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/guides-modules/save-simple-form-results/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserGuideSimpleFormChoiceToJSON(requestParameters.userGuideSimpleFormChoice),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserGuideSimpleFormChoiceFromJSON(jsonValue));
    }

    /**
     * Save the results of a simple selection form.
     */
    async saveSimpleFormResultsGuideModule(requestParameters: SaveSimpleFormResultsGuideModuleRequest, initOverrides?: RequestInit): Promise<UserGuideSimpleFormChoice> {
        const response = await this.saveSimpleFormResultsGuideModuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updateAddressRaw(requestParameters: UpdateAddressRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Address>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateAddress.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/addresses/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AddressToJSON(requestParameters.address),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddressFromJSON(jsonValue));
    }

    /**
     */
    async updateAddress(requestParameters: UpdateAddressRequest, initOverrides?: RequestInit): Promise<Address> {
        const response = await this.updateAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     */
    async updateCustomUserDetailsRaw(requestParameters: UpdateCustomUserDetailsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<CustomUserDetails>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/user/`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomUserDetailsToJSON(requestParameters.customUserDetails),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomUserDetailsFromJSON(jsonValue));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     */
    async updateCustomUserDetails(requestParameters: UpdateCustomUserDetailsRequest, initOverrides?: RequestInit): Promise<CustomUserDetails> {
        const response = await this.updateCustomUserDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async updatePhoneRaw(requestParameters: UpdatePhoneRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Phone>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updatePhone.');
        }

        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/core/api/v1/phones/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PhoneToJSON(requestParameters.phone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PhoneFromJSON(jsonValue));
    }

    /**
     */
    async updatePhone(requestParameters: UpdatePhoneRequest, initOverrides?: RequestInit): Promise<Phone> {
        const response = await this.updatePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum ListGuidesGuideTypeEnum {
    Guide = 'guide',
    Onboarding = 'onboarding'
}
/**
    * @export
    * @enum {string}
    */
export enum ListOffersCategoryEnum {
    MoneyTransfer = 'money-transfer',
    StudentLoans = 'student-loans',
    CreditBuildingCards = 'credit-building-cards',
    CreditCards = 'credit-cards',
    CreditBuilder = 'credit-builder',
    Banking = 'banking'
}
/**
    * @export
    * @enum {string}
    */
export enum RetrieveGuideGuideTypeEnum {
    Guide = 'guide',
    Onboarding = 'onboarding'
}
/**
    * @export
    * @enum {string}
    */
export enum RetrieveOfferCategoryEnum {
    MoneyTransfer = 'money-transfer',
    StudentLoans = 'student-loans',
    CreditBuildingCards = 'credit-building-cards',
    CreditCards = 'credit-cards',
    CreditBuilder = 'credit-builder',
    Banking = 'banking'
}
